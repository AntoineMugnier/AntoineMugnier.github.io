<!DOCTYPE html>

<head>
  <link rel="stylesheet" href="assets/css/header.css">
  <link rel="stylesheet" href="assets/css/personal_projects/corps.css">
  <title> Portfolio - Antoine Mugnier</title>
</head>

<body>
  <div class=index-page>
    <header>
      <div class=left-header>
        <span class=title-header>
          Antoine MUGNIER
        </span>
      </div>
      <div class=right-header>
        <div class="tooltip-container">
          <a href="index.html" class=tooltip-btn>
            About
          </a>
        </div>
        <div class="tooltip-container">
          <a href="resume.html" class=tooltip-btn>
            Resume
          </a>
        </div>
        <div class="tooltip-container">
          <a href="professional_projects.html" class=tooltip-btn>
            Professional Projects
          </a>
        </div>
        <div class="tooltip-container-active">
          <a href="personal_projects.html" class=tooltip-btn>
            Personal Projects
          </a>
        </div>
        <div class="tooltip-container">
          <a href="contact_me.html" class=tooltip-btn>
            Contact Me
          </a>
        </div>
      </div>
    </header>
    <main>
      <div class="corps">
        <div class="projects">
          <div class="kaori-hsm-project">
            <h3>&#8226 <a class="hyperlink" target="_blank"
                href="https://github.com/AntoineMugnier/kaori-hsm">Kaori-HSM</a>, an event-driven Hierarchical State
              Machine (HSM) library in Rust (Released in January 2024)</h3>

            <p>Hierarchical state machines (HSMs) are an extension of traditional state machines where states can be
              nested within one another. This nesting allows for a hierarchical organization of states, enabling more
              complex and modular state-based behavior modeling. In HSMs, nested states inherit event handling from
              their parent states, reducing redundancy and improving code organization.
            </p>
            <p>
              This crate provides an interface that allows developers to create their own HSMs as Rust code.
              Once created, custom events can be successively injected into the state machine, which will lead it
               to execute specific user-defined actions and transition to other states.
              As this crate is primarily destined to be run on microcontrollers, I have put special effort in limiting
              both program size and its stack usage.
              There is also no use of dynamic memory. The library is thoroughly tested, and I even made <a
                class="hyperlink" target="_blank" href="https://github.com/AntoineMugnier/kaori-hsm-perf-test"> a
                specific test </a> to compare its performance to the C++ QEP library, running on a STM32f103
              microcontroller.
            </p>
            <p>
              I hope in a close future to be able to add more crates working in synergy with Kaori-HSM, I'm thinking for
              example of
              a tool generating statechart diagrams
              from Kaori-HSM state machine code, a crate for performing unit test on Kaori-HSM and maybe also of a crate
              for checking the state machine written by the developer respects
              UML 2.5 standard.
            </p>
            <img class=kaori-example src="assets/images/kaori_hsm_example.png">
          </div>
          <div class="cortex-m-microclock-project">
            <h3>&#8226 <a class="hyperlink" target="_blank"
                href="https://github.com/AntoineMugnier/cortex-m-microclock">Cortex-M-Microclock</a>, a Rust crate for
              measuring time Cortex-M processors (released in November 2023)</h3>
            <p> This crate lays on the 32 bits CYCCNT counter present in most Cortex-M processor, which increments with
              each system clock tick.
              It gives to the user the ability to produce blocking delays and also to retrieve timestamps which can be
              compared with each other to measure time.
            </p>
          </div>
          <div class="ruthless-flow">
            <h3>&#8226 <a class="hyperlink" target="_blank"
                href="https://github.com/AntoineMugnier/ruthless_flow">Ruthless Flow</a>, a small game in Rust (released
              February 2023)</h3>
            <p>
              I developed this small game to improve my skill in Rust. It consists of a snake that you have to guide
              through the exit of a perpetually scrolling maze.
              The difficulty of the game lies in the demultiplication of the snake heads when you pass over specific
              cells. When this occurs, you should merge the
              heads back together as fast as possible to avoid explosion of heads numbers. You lose if any head gets
              caught by the bottom of the scrolling map.
            </p>
            <img class=ruthless-flow-screenshot src="assets/images/ruthless_flow.png">
          </div>
        </div>
      </div>
    </main>
  </div>
</body>